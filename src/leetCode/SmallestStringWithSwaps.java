package leetCode;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;

/**
 * 给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。
 * 你可以 任意多次交换 在 pairs 中任意一对索引处的字符。 返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。
 * 
 * @author 14257
 *查并集
 */
public class SmallestStringWithSwaps {
	public static void main(String[] args) {
		String s = "dcab";
		List<List<Integer>> pairs = new ArrayList<>();
		List<Integer> pair = new ArrayList<>();
		pair.add(0);
		pair.add(3);
		List<Integer> pair1 = new ArrayList<>();
		pair1.add(1);
		pair1.add(2);
		List<Integer> pair2 = new ArrayList<>();
		pair2.add(0);
		pair2.add(2);
		pairs.add(pair);
		pairs.add(pair1);
		pairs.add(pair2);
		System.out.println(pairs);
		if (pairs.size() == 0) {
//	            return s;
		}

		// 第 1 步：将任意交换的结点对输入并查集
		int len = s.length();
		UnionFind unionFind = new UnionFind(len);
		for (List<Integer> pair3 : pairs) {
			int index1 = pair3.get(0);
			int index2 = pair3.get(1);
			unionFind.union(index1, index2);
		}

		// 第 2 步：构建映射关系
		char[] charArray = s.toCharArray();
		// key：连通分量的代表元，value：同一个连通分量的字符集合（保存在一个优先队列中）
		Map<Integer, PriorityQueue<Character>> hashMap = new HashMap<>(len);
		for (int i = 0; i < len; i++) {
			int root = unionFind.find(i);
			if (hashMap.containsKey(root)) {
				hashMap.get(root).offer(charArray[i]);
			} else {
				// PriorityQueue<Character> minHeap = new PriorityQueue<>();
				// minHeap.offer(charArray[i]);
				// hashMap.put(root, minHeap);
				// 上面三行代码等价于下面一行代码，JDK 1.8 以及以后支持下面的写法
				hashMap.computeIfAbsent(root, key -> new PriorityQueue<>()).offer(charArray[i]);
			}
			System.out.println(hashMap);
		}

		// 第 3 步：重组字符串
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < len; i++) {
			int root = unionFind.find(i);
			stringBuilder.append(hashMap.get(root).poll());
		}
		System.out.println(stringBuilder.toString());
	}
	

	private static class UnionFind {

		private int[] parent;
		/**
		 * 以 i 为根结点的子树的高度（引入了路径压缩以后该定义并不准确）
		 */
		private int[] rank;

		public UnionFind(int n) {
			this.parent = new int[n];
			this.rank = new int[n];
			for (int i = 0; i < n; i++) {
				this.parent[i] = i;
				this.rank[i] = 1;
			}
		}

		public void union(int x, int y) {
			int rootX = find(x);
			int rootY = find(y);
			if (rootX == rootY) {
				return;
			}

			if (rank[rootX] == rank[rootY]) {
				parent[rootX] = rootY;
				// 此时以 rootY 为根结点的树的高度仅加了 1
				rank[rootY]++;
			} else if (rank[rootX] < rank[rootY]) {
				parent[rootX] = rootY;
				// 此时以 rootY 为根结点的树的高度不变
			} else {
				// 同理，此时以 rootX 为根结点的树的高度不变
				parent[rootY] = rootX;
			}
		}

		public int find(int x) {
			if (x != parent[x]) {
				parent[x] = find(parent[x]);
			}
			return parent[x];
		}

	}
}
